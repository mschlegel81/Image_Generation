private language:='Pascal';
persistent fileCheckedAtTime:=[];

private synchronized fileMustBeChecked(filename:string)->begin
  local checkTime:=fileCheckedAtTime%filename;
  checkTime==[] OR //One second tolerance:
  checkTime+1/(24*60*60)<fileInfo(filename)%'time';
end;

private synchronized fileWasChecked(filename:string)->fileCheckedAtTime.put(filename,fileInfo(filename)%'time');

private fixFileLines(S:stringList)->
  pEach(s,S,trim(s)="" ? "" : 
    pEach(token,tokenSplit(s,language),
      autoDict.get(upper(token),token)).join.trimRight);

private significance(count:int,literal:string)->max(0,count-1)*max(0,length(literal)-10);

memoized allFiles->files((allFolders('.')&'/*.pas')|(allFolders('.')&'/*.inc'));
mutable autoDict:=void;
synchronized prepareDict->autoDict:=
begin
  local result:=flatten(pEach(file,allFiles,fileContents(file).tokenSplit('pascal')));
  result:=elementFrequency(result%(regex.matches(result,'^[a-zA-Z][a-zA-Z_]+')));
  result:=pEach(idsGroup,group(result,upper(result%%1)),
      idsGroup.size>1
      ? [upper(idsGroup%0%1),idsGroup%argMax(idsGroup%%0)%1]
      : void);
end;

private checkConsistency(fileList)->begin
  local allTokens:=flatten(pEach(file,fileList,fileContents(file).tokenSplit('pascal')));
  print('Collected ',size(allTokens),' tokens');
  local allIds     :=allTokens%(regex.matches(allTokens,'^[a-zA-Z][a-zA-Z_]+'));
  print('Filtered ',size(allIds),' identifiers and keywords');
  local allLiterals:=allTokens%(regex.matches(allTokens,"^['0-9]"));
  print('Filtered ',size(allLiterals),' literals');
  allIds:=elementFrequency(allIds);
  
  local anyComplaints:=false;
  pEach(idsGroup,group(allIds,upper(allIds%%1)),
    idsGroup.size>1
    ? begin
        anyComplaints:=true;
        print('Inconsistent spelling: ',idsGroup.sort);
      end
    : void);

  not(anyComplaints) ? print('Spelling is consistent.') : void;
  allLiterals:=pEach(fp,allLiterals.elementFrequency,begin
                       local s:=significance@fp;
                       s>0 ? (-s)|fp
                           : void;
                     end).sort.head(20);
  print('Most significant literals: ');
  printf("%s\t%s\t%s",-(allLiterals%%0),allLiterals%%1,allLiterals%%2);
  void;
end; 

private pattern:='checkstyle: %-'&max(length(allFiles))&'s (%4d lines) ';

private fix(filename:string,readOnly:boolean)->begin
  local oldLines:=fileLines(filename);
  local newLines:=fixFileLines(oldLines);
  local diffOut:=format(pattern,filename,size(oldLines));
  oldLines==newLines ? diffOut&=' ok' : begin
    readOnly ? diffOut&=' NOT OKAY:' : diffOut&=' FIXED:';
    diffOut|=each(i,[0..size(newLines)-1],oldLines%i<>newLines%i ? '   <'&(oldLines%i)&">\n   >"&(newLines%i)&'<' : void);
    readOnly ? void : writeFileLines(filename,newLines);
  end;
  readOnly ? void : fileWasChecked(filename);
  printf('%s',diffOut);
end;

//*Check all files, writing out potential fixes
main("check")->begin
  prepareDict;
  pEach(s,allFiles,fix(s,true));
  print('Checking spelling consistency in MNH sources');
  checkConsistency(allFiles);
end;

//*Fix all files, writing out fixes
main("fix")->begin
  local filesToBeChecked:=pEach(file,allFiles,fileMustBeChecked(file) ? file : void);
  filesToBeChecked==[] 
  ? void 
  : begin
      prepareDict==[]
      ? void
      : pEach(file,filesToBeChecked,fix(file,false));
    end;
end;
