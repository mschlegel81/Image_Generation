language:='Pascal';
myDict:=unique(['UNIT','PROGRAM','PROCEDURE','FUNCTION','CONSTRUCTOR','DESTRUCTOR','VAR','CONST','OUT','INTERFACE',
         'IMPLEMENTATION','INITIALIZATION','FINALIZATION','if','then','else','case','begin','end','repeat','until',
         'while','do','to','in','ansistring','of','try','except','finally','true','false','value','word','longint',
         'result','assign','reset','rewrite','close','object','record','create','destroy','toString','inherited',
         'setLength','USES','TYPE','array','with','class','C_ID_QUALIFY_CHARACTER','inc','dec',
         "add","append","ARect","Attr","background","beginThread","boolean","bufferSize",
         "callDepth","char","Classes","clear","color","correlation","count","data","dotPos",
         "drive","dword","enterCriticalSection","eof","executable","execute","exit","exitStatus",
         "expandFileName","expression","extended","extractFileExt","extractFileName",
         "extractFilePath","extractRelativePath","factor","file","fileAge","fileExists",
         "fileList","fileName","filePath","fLine","for","foreground","format","formatFloat",
         "free","fTokenId","getEnumName","getRange","hashMask","height","high","hour",
         "index","int64","integer","intToStr","isNan","isUnique","key","leaveCriticalSection",
         "left","line","lines","lowercase","math","maxLongint","message","mnh_litVar","mnh_tokLoc",
         "mrOk","myGenerics","name","Nan","newValue","next","now","oldLen","options","ord","outFile",
         "output","override","paramCount","parameters","paramStr","PByte","point","pointer","poWaitOnExit",
         "PROPERTY","pSize","P_literal","P_token","rereference","round","running","saveToFile","screen",
         "section","self","setRange","shortString","showing","size","sleep","sourceValue","split","start",
         "startTime","stdErr","string","strToFloatDef","strToIntDef","style","subRule","sysutils","text",
         "textFile","time","title","tmp","top","trim","trimLeft","trimRight","trunc","tt_EOL","T_file","T_token",
         "uppercase","virtual","width","windows","write","writeln","xor"]);
upperDict:=upper(myDict);
fixToken(s:string)->upper(s) in upperDict and not(s in myDict) ? head(myDict%(upper(myDict)=upper(s))) : s;
fixLine(s:string)->trim(s)="" ? "" : trimRight(each(token,tokenSplit(s,language),&,fixToken(token)));
fixFileLines(S:stringList)->pEach(s,S,fixLine(s));
isIdentifier(x:string)->length(x)>1 and regex.matches(x,'^[a-zA-Z_]+');

checkConsistency(fileList)->begin
  local all:=unique(flatten(pEach(file,fileList,each(tok,tokenSplit(fileContents(file),'pascal'),isIdentifier(tok) AND not(tok in upperDict) ? tok : void))));
  local allUp:=unique(upper(all));
  local anyComplaints:=false;
  each(x,allUp,trueCount(upper(all)=x)>3 
  ? begin
      anyComplaints:=true;
      print('Inconsistent spelling: ',all%(upper(all)=x));
    end;
  : void);
  not(anyComplaints) ? print('Spelling is consistent.') : void;  
  void;
end;

allFiles:=files((allFolders('.')&'/*.pas')|(allFolders('.')&'/*.inc'));
pattern:='checkstyle: %X'&max(length(allFiles))&'% (%I5% lines) ';

fix(filename,readOnly)->begin
  local oldLines:=fileLines(filename);
  local newLines:=fixFileLines(oldLines);
  local diffOut:=format(pattern,filename,size(oldLines));
  oldLines==newLines ? diffOut&=' ok' : begin
    readOnly ? diffOut&=' NOT OKAY:' : diffOut&=' FIXED:';
    diffOut|=each(i,[0..size(newLines)-1],oldLines%i<>newLines%i ? '   <'&(oldLines%i)&">\n   >"&(newLines%i)&'<' : void);
    readOnly ? void : writeFileLines(filename,newLines);
  end;
  printf('%X%',diffOut);
end;

//*Check all files, writing out potential fixes
main("check")->begin
  pEach(s,allFiles,fix(s,true));
  print('Checking spelling consistency in MNH sources');
  checkConsistency(allFiles);
end;


//*Fix all files, writing out fixes
main("fix")->pEach(s,allFiles,fix(s,false));